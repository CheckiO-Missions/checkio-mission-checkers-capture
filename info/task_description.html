<!-- Describe task in general -->

<p>
    Imagine a <b class="code">n</b>-by-<b class="code">n</b> chessboard, where your single checker currently stands at <b class="code">position</b> (x, y) and there is <b class="code">pieces</b> - a list that contains the positions of the opponent’s pawns. 
</p>
<p style="text-align: justify;">
    Your checker may capture a piece only one step in the four diagonal directions assuming that the square behind the opponent piece in that diagonal direction is vacant. Your checker can then capture that piece by jumping over it into the vacant square, immediately removing that captured piece from the board. The chain of captures continues from the new square, potentially capturing all the pieces in one swoop. 
</p>
<p>
    Your function should return the maximum number of pieces that your checker could potentially capture in a single move.
</p>

<!-- <p style="text-align: center;">
    <img  title="example" src="{{MEDIA}}example.png" alt="example" style="max-height: 83px"/>
</p> -->

<!-- Explain input and output values -->
<p>
    <strong>Input:</strong> Three arguments: size <span translate="no">({% if is_js %}number{% else %}int{% endif %})</span>, coordinates (<span translate="repeat">{% if is_js %}array{% else %}tuple{% endif %}</span> of two integers <span translate="no">({% if is_js %}number{% else %}int{% endif %})</span>) and a sequence of opponent's pieces (<span translate="repeat">{% if is_js %}array{% else %}list{% endif %}</span> of coordinates).
</p>

<p>
    <strong>Output:</strong> Integer <span translate="no">({% if is_js %}number{% else %}int{% endif %})</span>. 
</p>


<p>
    <strong>Examples:</strong>
</p>

<pre class="brush: {% if is_js %}javascript{% else %}python{% endif %}">{{init_code_tmpl}}</pre>

<details>
    <summary><i>Need a small hint? Click on</i></summary>
    <p style="text-align: justify;"><i>
        The maximum number of pieces that can be captured in a single move is best computed with a method that locally loops through the four diagonal directions from the current position of the king. For each such direction that contains an opponent piece with a vacant space behind it, remove that opponent piece from the board, and recursively compute the number of pieces that can be captured from the vacant square that your king jumps into. Once that recursive call has returned, restore the captured piece on the board, and continue looping to the next diagonal direction. The number of captures of whichever direction gives the best result from that square is returned as the answer.
    </i></p>
</details>

<p><i>The mission was taken from <span translate="no">Python CCPS 109</span>. It is taught for <span translate="no">Ryerson Chang School of Continuing Education</span> by <a href="http://www.scs.ryerson.ca/~ikokkari/">Ilkka Kokkarinen</a></i></p>

<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<!-- <p class="for_info_only">

    <strong>How it’s used:</strong>
    <i>(math is used everywhere)</i>
</p> -->

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<!-- <p>
    <strong>Preconditions:</strong>
    <ul>
    <li><i>both given ints should be between -1000 and 1000</i></li>
    </ul>
</p> -->
