<!-- Describe task in general -->

<img src="{{MEDIA_CONVERT}}title.png" class="title_img" />

<p>
    Imaginez un échiquier <b class="code">n</b>-par-<b class="code">n</b>, où votre unique pion se trouve actuellement à <b class="code">position</b> (x, y) et où il y a <b class="code">pieces</b> - une liste qui contient les positions des pions de l'adversaire. 
</p>
<p style="text-align: justify;">
    Votre pion peut capturer une pièce d'un seul pas dans les quatre directions diagonales, à condition que la case située derrière la pièce adverse dans cette direction diagonale soit libre. Votre pion peut alors capturer cette pièce en sautant par-dessus elle sur la case vacante, retirant immédiatement la pièce capturée de l'échiquier. La chaîne de captures se poursuit à partir de la nouvelle case, ce qui permet de capturer toutes les pièces d'un seul coup. 
</p>
<p>
    Votre fonction doit renvoyer le nombre maximum de pièces que votre pion peut capturer en un seul coup.
</p>

<!-- <p style="text-align: center;">
    <img  title="example" src="{{MEDIA}}example.png" alt="example" style="max-height: 83px"/>
</p> -->

<!-- Explain input and output values -->
<p>
   <strong>Entrée:</strong> Trois arguments: taille <span>({% if is_js %}number{% else %}int{% endif %})</span>coordonnées ({% if is_js %}tableau{% else %}tuple{% endif %} <span>({% if is_js %}array{% else %}tuple{% endif %})</span> de deux entiers <span>({% if is_js %}number{% else %}int{% endif %})</span>) et une séquence de pièces de l'adversaire ({% if is_js %}tableau{% else %}liste{% endif %} <span>({% if is_js %}array{% else %}list{% endif %})</span> de coordonnées).
</p>

<p>
   <strong>Résultat:</strong> Entier <span>({% if is_js %}number{% else %}int{% endif %})</span>. 
</p>


<p>
    <strong>Exemples:</strong>
</p>

<pre class="brush: {% if is_js %}javascript{% else %}python{% endif %}">{{init_code_tmpl}}</pre>

<details>
    <summary><i>Besoin d'un petit conseil? Cliquez sur</i></summary>
    <p style="text-align: justify;"><i>
        Le nombre maximum de pièces qui peuvent être capturées en un seul coup est mieux calculé avec une méthode qui boucle localement les quatre directions diagonales à partir de la position actuelle du roi. Pour chacune de ces directions qui contient une pièce adverse avec une case vide derrière elle, retirez cette pièce de l'échiquier et calculez de manière récursive le nombre de pièces qui peuvent être capturées à partir de la case vide sur laquelle votre roi saute. Une fois que l'appel récursif est revenu, remettez la pièce capturée sur l'échiquier et continuez la boucle jusqu'à la direction diagonale suivante. Le nombre de captures dans la direction qui donne le meilleur résultat à partir de cette case est renvoyé comme réponse.
    </i></p>
</details>

<p><i>La mission a été tirée de <span>Python CCPS 109</span>. Elle est enseignée pour <span>Ryerson Chang School of Continuing Education</span> par <a href="https://github.com/ikokkari">Ilkka Kokkarinen</a></i></p>

<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<!-- <p class="for_info_only">

    <strong>How it’s used:</strong>
    <i>(math is used everywhere)</i>
</p> -->

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<!-- <p>
    <strong>Preconditions:</strong>
    <ul>
    <li><i>both given ints should be between -1000 and 1000</i></li>
    </ul>
</p> -->
